import type { WrapupLogEntry } from './messages.js';
import { JsonlLogEntry, readLogEntriesStrict } from './logs.js';
import fs from 'fs';
import path from 'path';
import paths from './paths.js';
import xmlEscape from 'xml-escape';
import { z } from 'zod';
import { zodToJsonSchema } from 'zod-to-json-schema';

const QUOTE_SCHEMA = z
	.object({
		speaker: z
			.string()
			.min(1)
			.describe('Speaker name as heard in the transcript (display name or alias).'),
		text: z
			.string()
			.min(1)
			.describe(
				'Exact quote from the transcript; do not fabricate, unless to correct transcription errors.',
			),
	})
	.describe('A memorable quote from a scene.');

const CONVERSATION_SCHEMA = z
	.object({
		title: z.string().describe('Short title/context for the conversation.'),
		quotes: z
			.array(QUOTE_SCHEMA)
			.min(1)
			.describe('One or more memorable quotes in a conversation.'),
	})
	.describe('A group of one or more memorable quotes from a conversation.');

const SCENE_SCHEMA = z
	.object({
		title: z.string().describe('Optional short scene title.'),
		summary: z.string().describe('Narrative summary of events in the scene.'),
		quotes: z
			.array(CONVERSATION_SCHEMA)
			.optional()
			.describe('Highly memorable quotes from the scene.'),
		items: z
			.array(z.string())
			.optional()
			.describe(
				'Identify any items/rewards spent, exchanged, or earned in this scene for inventory management.',
			),
		developments: z
			.array(z.string())
			.optional()
			.describe('Significant plot developments or discoveries.'),
		combat: z
			.string()
			.optional()
			.describe('If present, outcome and key actions of combat in this scene.'),
	})
	.describe('One scene in the session, in chronological order.');

export const WRAPUP_SCHEMA = z
	.object({
		title: z.string().describe('Title for the session.'),
		context: z
			.string()
			.optional()
			.describe('Optional context or summary tying the previous session into this one.'),
		scenes: z
			.array(SCENE_SCHEMA)
			.nonempty()
			.describe('List of major scenes in chronological order.'),
		keyFindings: z
			.array(z.string())
			.optional()
			.describe('Overall key takeaways for the session.'),
	})
	.describe('Structured wrapup output for the session.');

type WrapupData = z.infer<typeof WRAPUP_SCHEMA>;

// Recursively transform a JSON schema to be compatible with Gemini (strip unsupported keys)
function transformSchema(schema: any): any {
	if (Array.isArray(schema)) return schema.map((s) => transformSchema(s));
	if (schema && typeof schema === 'object') {
		const out: Record<string, any> = {};
		for (const [key, value] of Object.entries(schema)) {
			if (key === 'additionalProperties') continue; // drop
			if (
				key === 'properties' &&
				value &&
				typeof value === 'object' &&
				!Array.isArray(value)
			) {
				const props: Record<string, any> = {};
				for (const [pkey, pval] of Object.entries(value as Record<string, any>)) {
					props[pkey] = transformSchema(pval);
				}
				out.properties = props;
				continue;
			}
			if (key === 'items') {
				out.items = transformSchema(value);
				continue;
			}
			if (key === 'anyOf' || key === 'oneOf' || key === 'allOf') {
				out[key] = Array.isArray(value)
					? (value as any[]).map((v) => transformSchema(v))
					: transformSchema(value);
				continue;
			}
			out[key] = transformSchema(value);
		}
		return out;
	}
	return schema;
}

function buildGeminiSchema(): any {
	const jsonSchema = zodToJsonSchema(WRAPUP_SCHEMA, {
		name: 'Wrapup',
		$refStrategy: 'none' as any,
	} as any);
	const root = (jsonSchema as any).definitions?.Wrapup || jsonSchema;
	return transformSchema(root);
}

// Cache the transformed schema so we don't recompute every invocation
const GEMINI_RESPONSE_SCHEMA = buildGeminiSchema();

export const DEFAULT_SYSTEM_PROMPT = `
You will be given a raw voice chat transcript of a D&D 5e game session.
Be aware that the transcript is generated by an AI speech-to-text model and contains many errors, misinterpretations, and artifacts.
You will need to internally account for and correct mistakes in order to form a coherent understanding of the story and scenes.
After interpreting the transcript, generate a detailed and coherent recap, suitable for use as a player's reference material for subsequent sessions.
Within each scene recap:
  - Incorporate memorable or defining quotes that occured during that scene.
  - Any items exchanged, rewards earned, discoveries, or significant plot developments should be noted in detail.
  - Highlight any funny or unexpected moments and roleplay elements.
  - For combat, it's okay to only cover the most impactful actions, but be sure to include the outcome of the encounter.
Make sure your recap follows the order of events as they unfold in the transcript. Do not make up quotes, and always attribute them.
Maintain a playful, engaging, and enthusiastic tone without being long-winded.
If returning a JSON response, you should completely omit optional fields if they have no meaningful content.
`;

export function generateTranscript(logEntries: WrapupLogEntry[], sessionName: string): string {
	const lines: string[] = [`# Transcript for session: ${sessionName}\n`];
	for (const e of logEntries) {
		lines.push(`${e.user_name}: ${e.text}`);
	}
	return lines.join('\n');
}

export interface WrapupOptions extends GeminiOptions {
	sessionName: string;
	userIdMap?: Record<string, string>;
	phraseMap?: Record<string, string>;
	vocabulary?: string[];
	forceNew?: boolean; // if true, regenerate even if wrapup exists
	prevSessionName?: string; // optional previous session name to include its wrapup as context
}

/**
 * Generates a session wrap-up outline by reading logs, creating a transcript,
 * and calling the Gemini API.
 * @param opts The options for generating the wrap-up.
 * @returns The generated outline as a string.
 * @throws An error if logs are empty or the API key is missing.
 */
export async function createWrapup(opts: WrapupOptions): Promise<string> {
	// Determine session directory and wrapup path
	const sessionDir = paths.sessionDataDir(opts.sessionName);
	paths.ensureDir(sessionDir);
	const wrapupPath = path.join(sessionDir, 'wrapup.md');

	// If exists and not forcing regeneration, return it immediately (no API key required)
	if (!opts.forceNew && fs.existsSync(wrapupPath)) {
		console.log(`[wrapup] Using cached wrapup: ${wrapupPath}`);
		return fs.readFileSync(wrapupPath, 'utf8');
	}

	const logPath = paths.sessionLogPath(opts.sessionName);
	const entries = await readLogEntriesStrict(logPath);
	if (!entries.length) {
		// Let callers handle this case with user-facing messages
		throw new Error('No log entries found for session.');
	}
	const transformed = entries.map((e) => toWrapupLogEntry(e, opts.userIdMap, opts.phraseMap));
	const transcript = generateTranscript(transformed, opts.sessionName);

	// Optionally load previous session wrapup for context
	let previousWrapup = '';
	if (opts.prevSessionName) {
		const prevPath = paths.sessionWrapupPath(opts.prevSessionName);
		if (fs.existsSync(prevPath)) {
			try {
				previousWrapup = fs.readFileSync(prevPath, 'utf8');
			} catch (_) {
				// ignore read errors and proceed without prior context
			}
		}
	}
	// Build XML input combining prior wrapup (if any) and current transcript
	const vocabBlock =
		opts.vocabulary && opts.vocabulary.length
			? `<phrase>\n${xmlEscape(opts.vocabulary.join('\n'))}\n</phrase>`
			: '';
	const xmlInput = [
		'<wrapup_request>',
		`<previous_wrapup>\n${xmlEscape(previousWrapup)}\n</previous_wrapup>`,
		`<vocabulary>\n${vocabBlock}\n</vocabulary>`,
		`<transcript>\n${xmlEscape(transcript)}\n</transcript>`,
		'</wrapup_request>',
	].join('\n');

	if (!opts.apiKey) {
		throw new Error('GEMINI_API_KEY must be set to run wrapup.');
	}

	// Pre-built structured output schema (defined once at module scope)
	const responseSchema = GEMINI_RESPONSE_SCHEMA;

	console.log(`[wrapup] Requesting wrapup...`);
	// Request JSON, validate with Zod, and render to Markdown
	const jsonText = await generateWrapupWithGemini(xmlInput, {
		apiKey: opts.apiKey,
		model: opts.model,
		prompt: opts.prompt,
		temperature: opts.temperature,
		maxOutputTokens: opts.maxOutputTokens,
		tips: opts.tips,
		responseMimeType: 'application/json',
		responseSchema,
	});
	const parsed = JSON.parse(jsonText) as unknown;
	const data = WRAPUP_SCHEMA.parse(parsed) as WrapupData;
	const markdownOut = renderWrapupMarkdown(data);
	fs.writeFileSync(wrapupPath, markdownOut, 'utf8');
	console.log(`[wrapup] Wrote markdown: ${wrapupPath}`);
	return markdownOut;
}

export interface GeminiOptions {
	apiKey: string;
	model?: string; // e.g., 'gemini-2.5-flash'
	prompt?: string;
	tips?: string[];
	temperature?: number;
	maxOutputTokens?: number;
	responseMimeType?: string;
	responseSchema?: any;
}

export class LLMRequestError extends Error {
	code: number | string;
	constructor(code: number | string, message: string) {
		super(`Gemini request failed: ${code} - ${message}`);
		this.code = code;
		this.name = 'LLMRequestError';
	}
}

export async function generateWrapupWithGemini(
	transcript: string,
	opts: GeminiOptions,
): Promise<string> {
	const model = opts.model || 'gemini-2.5-flash';
	const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;

	// Build system prompt and optionally append tips as a bulleted list
	let systemPrompt = opts.prompt || DEFAULT_SYSTEM_PROMPT;
	if (opts.tips && opts.tips.length) {
		const tipBlock = opts.tips.map((t) => `- ${t}`).join('\n');
		systemPrompt = `${systemPrompt}\nHere are some additional tips:\n${tipBlock}\n`;
	}

	const payload: any = {
		system_instruction: { parts: [{ text: systemPrompt }] },
		contents: { parts: [{ text: transcript }] },
		generationConfig: {
			maxOutputTokens: opts.maxOutputTokens ?? 8192,
			temperature: opts.temperature ?? 0.2,
			thinkingConfig: { thinkingBudget: -1 },
		},
	};

	if (opts.responseMimeType) {
		payload.generationConfig.responseMimeType = opts.responseMimeType;
	}
	if (opts.responseSchema) {
		payload.generationConfig.responseSchema = opts.responseSchema;
	}

	const resp = await fetch(endpoint, {
		method: 'POST',
		headers: {
			'x-goog-api-key': opts.apiKey,
			'Content-Type': 'application/json',
		},
		body: JSON.stringify(payload),
	});

	if (!resp.ok) {
		let errMsg = await resp.text();
		try {
			const j = await resp.clone().json();
			if (j && typeof j === 'object' && j.error) {
				errMsg = j.error.message || errMsg;
				throw new LLMRequestError(j.error.code ?? resp.status, errMsg);
			}
		} catch (_) {
			// ignore JSON parse errors; fall through to generic error
		}
		throw new LLMRequestError(resp.status, errMsg);
	}

	const data = await resp.json();
	// Extract text content (JSON string if responseMimeType=application/json)
	const text = data?.candidates?.[0]?.content?.parts?.[0]?.text;
	if (!text || typeof text !== 'string') {
		console.log(data);
		throw new Error('Unexpected Gemini response shape (no text found)');
	}
	return text;
}

function renderWrapupMarkdown(data: {
	title: string;
	context?: string;
	scenes: any[];
	keyFindings?: string[];
}): string {
	const lines: string[] = [];
	lines.push(`# ${data.title}`);
	if (data.context) {
		lines.push(`\n## Context`);
		lines.push(data.context);
	}
	if (data.keyFindings && data.keyFindings.length) {
		lines.push('\n## Session Developments');
		for (const k of data.keyFindings) lines.push(`- ${k}`);
	}
	data.scenes.forEach((scene, idx) => {
		const title = scene.title || `Scene ${idx + 1}`;
		lines.push(`\n## ${title}`);
		if (scene.summary) lines.push(`\n${scene.summary}`);
		if (scene.quotes && scene.quotes.length) {
			lines.push('\n### Quotes');
			for (const c of scene.quotes) {
				lines.push(`#### ${c.title}`);
				lines.push(
					...c.quotes.map(
						(q: { speaker: string; text: string }) => `* **${q.speaker}**: *${q.text}*`,
					),
				);
			}
		}
		if (scene.items && scene.items.length) {
			lines.push('\n### Items / Rewards');
			for (const it of scene.items) lines.push(`- ${it}`);
		}
		if (scene.developments && scene.developments.length) {
			lines.push('\n### Developments');
			for (const d of scene.developments) lines.push(`- ${d}`);
		}
		if (scene.funnies && scene.funnies.length) {
			lines.push('\n### Highlights & Roleplay');
			for (const f of scene.funnies) lines.push(`- ${f}`);
		}
		if (scene.combat) {
			lines.push('\n### Combat');
			lines.push(scene.combat);
		}
	});
	lines.push('');
	return lines.join('\n');
}

// Convert stored JSONL entries (camelCase internal) into wire shape for wrapup,
// applying optional userid->alias mapping and phrase substitutions.
export function toWrapupLogEntry(
	entry: JsonlLogEntry,
	userIdMap?: Record<string, string>,
	phraseMap?: Record<string, string>,
): WrapupLogEntry {
	const alias = userIdMap?.[entry.userId];
	let text = entry.text;
	if (phraseMap && Object.keys(phraseMap).length) {
		for (const [src, dst] of Object.entries(phraseMap)) {
			if (!src) continue;
			text = text.replaceAll(src, dst);
		}
	}
	return {
		user_name: alias ?? entry.displayName,
		start_ts: entry.startTs,
		end_ts: entry.endTs,
		text,
		user_id: entry.userId,
	};
}
